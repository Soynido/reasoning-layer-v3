# ADRs (Architecture Decision Records)

This file contains Architecture Decision Records (ADRs) for this project.

## Format

Each ADR follows this structure:

```markdown
## ADR-XXX: [Title]

**Status**: proposed | accepted | rejected | deprecated | superseded
**Date**: YYYY-MM-DD
**Author**: [Author name]

### Context

[Describe the context and problem that led to this decision]

### Decision

[Describe the decision made]

### Consequences

**Positive:**
- [List positive consequences]

**Negative:**
- [List negative consequences]

**Risks:**
- [List potential risks]

**Alternatives Considered:**
- [List alternatives that were considered]
```

## How to Use

1. When the LLM (agent) proposes an ADR, add it to this file
2. RL4 will automatically detect the change and parse it
3. The ADR will be added to the ledger (`.reasoning_rl4/ledger/adrs.jsonl`)
4. Future prompts will include this ADR in the context

---

## ADR-010: 4-Tabs WebView Interface for RL4 Dashboard

**Status**: accepted
**Date**: 2025-11-15
**Author**: RL4 Development Team

### Context

The RL4 WebView dashboard initially had a simple single-button interface focused solely on snapshot generation. As RL4 evolved, we added multiple features (GitHub integration, commit workflow, KPI display, dev proposals) that were all crammed into one scrolling interface. User feedback indicated difficulty finding features and cognitive overload.

### Decision

Reorganize the WebView into 4 distinct tabs:
1. **Control Tab**: Core actions (snapshot generation, GitHub connect, deviation mode selector)
2. **Dev Tab**: Development workflow (proposals from LLM, patch preview, accept/reject decisions)
3. **Insights Tab**: Analytics (KPI dashboard with Cognitive Load, Next Steps, Plan Drift, Risks, Anomalies)
4. **About Tab**: Information cards explaining what RL4 does and how it works

### Consequences

**Positive:**
- Clear separation of concerns (action vs monitoring vs info)
- Reduced cognitive load (focused views)
- Better discoverability (features organized by purpose)
- Scalable structure (easy to add features to appropriate tab)
- Professional appearance (matches VS Code UI patterns)

**Negative:**
- Slightly more complex state management (activeTab state)
- Users must switch tabs to access different features
- More initial code to maintain

**Risks:**
- Users might not discover all tabs
- Tab switching adds interaction cost

**Mitigation:**
- Use clear tab labels with emoji icons
- Show badges on Dev tab when new proposals arrive
- Default to Control tab (most common use case)

**Alternatives Considered:**
- **Single scrolling page** - Rejected due to information overload
- **Collapsible sections** - Rejected due to poor VS Code integration
- **Separate webview panels** - Rejected due to window management complexity

---

## ADR-011: GitHub Integration with Fine-Grained Tokens

**Status**: accepted
**Date**: 2025-11-15
**Author**: RL4 Development Team

### Context

RL4 needs to integrate with GitHub for:
- Repository detection and status checking
- PR/Issue context in snapshots
- Commit workflow automation (commit + push + PR creation)

Classic Personal Access Tokens (PATs) are broad and require full repo access. GitHub now offers fine-grained tokens with specific permissions.

### Decision

Use GitHub fine-grained personal access tokens with minimal required permissions:
- `repository` ‚Üí `contents` (read/write) for commit/push
- `repository` ‚Üí `pull_requests` (read/write) for PR creation
- `repository` ‚Üí `metadata` (read) for repo info

### Consequences

**Positive:**
- Minimal permissions (security best practice)
- User controls exact scope of access
- Tokens can be revoked easily
- Clear audit trail in GitHub
- Works with private repos

**Negative:**
- Users must manually create token (not OAuth flow)
- More setup friction than classic PATs
- Requires users to understand fine-grained permissions

**Risks:**
- Users might create tokens with insufficient permissions
- Token expiration requires renewal

**Mitigation:**
- Provide clear setup instructions in webview
- Check token permissions on connection
- Display helpful error messages for insufficient permissions
- Store token securely in VS Code SecretStorage

**Alternatives Considered:**
- **Classic PATs** - Rejected due to overly broad permissions
- **GitHub OAuth App** - Rejected due to complexity of OAuth flow in extension
- **GitHub App** - Rejected due to requiring organization-level installation

---

## ADR-012: Commit with WHY Workflow (LLM-Assisted Git)

**Status**: accepted
**Date**: 2025-11-15
**Author**: RL4 Development Team

### Context

Traditional git commits often lack architectural context. Developers write brief commit messages but don't explain:
- WHY the change was made (architectural reasoning)
- HOW it fits into the project vision
- WHAT alternatives were considered

RL4 has complete project context (Plan, Tasks, Context, ADRs, diff) that could enrich commits with architectural insights.

### Decision

Implement "Commit with WHY" workflow:
1. User clicks "Generate Commit Prompt" in WebView
2. RL4 collects context: git diff, staged files, Plan.RL4, Tasks.RL4, Context.RL4, recent ADRs
3. RL4 generates prompt for LLM with instructions to create WHY + GH CLI command
4. User pastes prompt into their LLM (Claude/ChatGPT/etc)
5. LLM returns `RL4_COMMIT_VALIDATE { WHY: "...", COMMAND: "gh pr create..." }`
6. User pastes validation token back into WebView
7. WebView parses and displays WHY + Command preview
8. User validates ‚Üí RL4 executes full workflow (checkout branch, add, commit, push, create PR)

### Consequences

**Positive:**
- Commits enriched with architectural reasoning
- Consistent commit format across team
- PR descriptions auto-generated with context
- Reduces cognitive load (LLM does the synthesis)
- Creates audit trail of decision-making
- Works with any LLM (not tied to specific API)

**Negative:**
- Multi-step workflow (not one-click)
- Requires user to have LLM access
- Requires `gh` CLI installed
- More complex than traditional git commit

**Risks:**
- Users might skip WHY generation (too much friction)
- LLM might generate incorrect commands
- Users might not validate before executing

**Mitigation:**
- Show clear preview of command before execution
- Parse and validate `gh pr create` command format
- Display WHY prominently for user review
- Allow manual editing of command
- Provide easy cancel/discard option

**Alternatives Considered:**
- **Direct LLM API integration** - Rejected due to API key management complexity
- **Automatic commit without preview** - Rejected due to safety concerns
- **Traditional commit with optional WHY** - Rejected due to low adoption likelihood
- **Post-commit WHY annotation** - Rejected due to git history immutability

---

## ADR-013: Terminal D√©di√© RL4 for Tracked Commands

**Status**: accepted
**Date**: 2025-11-15
**Author**: RL4 Development Team

### Context

RL4 users frequently run commands related to the extension (build, package, install). These commands are scattered across regular terminals, making it hard to:
- Track which commands were run
- Reproduce build processes
- Debug installation issues
- Maintain clean terminal history

### Decision

Create a dedicated "RL4 Terminal" accessible via command palette:
- Command: `reasoning.terminal.openRL4`
- Single terminal instance (reused if already exists)
- Logged via CognitiveLogger for audit trail
- Clearly labeled "RL4 Terminal" for easy identification

### Consequences

**Positive:**
- Centralized location for RL4 commands
- Clean separation from other project work
- Logged for debugging and reproducibility
- Easy to find and reuse
- Professional appearance

**Negative:**
- One more terminal to manage
- Users must remember to use it
- Doesn't enforce usage (users can still use regular terminals)

**Risks:**
- Low adoption if not discoverable
- Terminal might be closed accidentally

**Mitigation:**
- Add to command palette with clear name
- Log terminal creation/show events
- Keep single instance (don't create duplicates)
- Make it easy to reopen if closed

**Alternatives Considered:**
- **Automatic command logging in all terminals** - Rejected due to privacy concerns
- **Output channel instead of terminal** - Rejected due to lack of interactivity
- **Task runner integration** - Rejected due to VS Code Tasks complexity

---

## ADR-009: Automated Testing Strategy for RL4 Extension

**Status**: ‚úÖ accepted

**Date**: 2025-11-16

**Author**: Agent LLM

**Related**: Extension development, quality assurance, CI/CD

### Context

Apr√®s 6h45min de d√©veloppement intensif (8 phases, 11 fichiers cr√©√©s, 391 fichiers uncommitted), le besoin d'une strat√©gie de validation automatis√©e est devenu critique pour:

1. **√âviter les r√©gressions** lors des refactors futurs
2. **Valider la coh√©rence** entre fichiers RL4 (Plan/Tasks/Context/proposals/terminal-events)
3. **Documenter le comportement attendu** (tests = documentation ex√©cutable)
4. **Acc√©l√©rer la review** avant commit (validation en <1min)

**Probl√®mes identifi√©s:**
- ‚ùå Extension packag√©e mais non test√©e manuellement ‚Üí Risque de bugs silencieux
- ‚ùå Fichiers JSONL/JSON sans validation schema ‚Üí Risque de corruption
- ‚ùå Markers `@rl4:id` / `@rl4:completeWhen` sans parser test ‚Üí Risque de parsing failures
- ‚ùå Workflow proposals.json ‚Üí Tasks.RL4 sans tests end-to-end

### Decision

**Approche retenue:** Script Bash autonome (`test-rl4-automation.sh`) ex√©cutable sans d√©pendances externes, avec:

1. **10 test suites couvrant:**
   - Installation & initialisation (structure .reasoning_rl4/)
   - Task Verification Engine (markers parsing)
   - Terminal Events Simulation (JSONL format)
   - LLM Proposal Workflow (bias calculation)
   - Ledgers & Logging (decisions.jsonl)
   - Cursor Rules (strict mode enforcement)
   - File Structure & Permissions
   - Content Validation (sections critiques)
   - Snapshot Reminder (timestamp format)
   - Integration Checks (coh√©rence inter-fichiers)

2. **46 tests automatis√©s:**
   - File existence checks
   - JSONL/JSON format validation (via Node.js)
   - Content pattern matching (grep)
   - Cross-file coherence (taskId matching)
   - Bias validation (total < 100%)

3. **Test data injection:**
   - Backup Tasks.RL4 original
   - Inject test tasks avec markers
   - Create simulated terminal-events.jsonl (9 events, 4 tasks)
   - Create test proposals.json (3 suggestions, 16% bias)
   - Create test decisions.jsonl (3 decision types)

4. **Cleanup automatique:**
   - Restore Tasks.RL4.backup apr√®s tests
   - Delete test script et r√©sultats apr√®s validation

### Consequences

**Positives:**
- ‚úÖ **97.8% success rate** (45/46 tests passed)
- ‚úÖ **<1min d'ex√©cution** (validation rapide avant commit)
- ‚úÖ **Aucune d√©pendance externe** (Bash + Node.js d√©j√† pr√©sents)
- ‚úÖ **Reproductible** (script versionn√© avec le projet)
- ‚úÖ **Documentation ex√©cutable** (tests = spec du comportement)
- ‚úÖ **D√©tection pr√©coce** de r√©gressions (ex: pattern matching "Phase:" ‚Üí d√©tect√©)

**N√©gatives:**
- ‚ö†Ô∏è **Tests simul√©s** (pas de vraie extension VS Code lanc√©e)
- ‚ö†Ô∏è **Pas de tests UI** (WebView non valid√© automatiquement)
- ‚ö†Ô∏è **Maintenance manuelle** (script Bash √† mettre √† jour si nouveaux features)

**Risks:**
- üü° **False positives** si patterns changent (ex: "Phase:" ‚Üí "Phase E4")
- üü° **Coverage partiel** (focus sur fichiers RL4, pas sur TypeScript)
- üü° **Pas d'int√©gration CI/CD** (script local uniquement pour l'instant)

**Alternatives Considered:**

1. **Jest + TypeScript unit tests**
   - ‚úÖ Meilleur coverage du code TypeScript
   - ‚ùå Requiert setup complexe (jest.config, tsconfig, mocks)
   - ‚ùå Lent (compilation + ex√©cution)
   - **Rejet√©:** Trop lourd pour validation rapide pre-commit

2. **VS Code Extension Test API**
   - ‚úÖ Tests end-to-end de l'extension r√©elle
   - ‚ùå Requiert instance VS Code headless
   - ‚ùå Tr√®s lent (>30s par test suite)
   - **Rejet√©:** Complexit√© setup + lenteur incompatible avec feedback rapide

3. **Manual testing checklist (Markdown)**
   - ‚úÖ Simple et flexible
   - ‚ùå Non reproductible
   - ‚ùå Erreur humaine
   - ‚ùå Lent (>15min de tests manuels)
   - **Rejet√©:** Pas automatisable

### Implementation Details

**Script structure:**
```bash
#!/bin/bash
# test-rl4-automation.sh

# 10 test suites:
# 1. Installation & Initialisation (9 tests)
# 2. Task Verification Engine Setup (4 tests)
# 3. Terminal Events Simulation (3 tests)
# 4. LLM Proposal Workflow (4 tests)
# 5. Ledgers & Logging (5 tests)
# 6. Cursor Rules (3 tests)
# 7. File Structure & Permissions (6 tests)
# 8. Content Validation (5 tests)
# 9. Snapshot Reminder (2 tests)
# 10. Integration Checks (5 tests)

# Counters: PASS=0, FAIL=0, TOTAL=46
# Result: 97.8% success rate
```

**Key validations:**
- ‚úÖ JSONL format: `node -e "require('fs').readFileSync('file.jsonl').split('\n').forEach(l => JSON.parse(l))"`
- ‚úÖ JSON schema: `node -e "const p = JSON.parse(...); if (!p.suggestedTasks) throw;"`
- ‚úÖ Marker presence: `grep -q "@rl4:id=task-001" Tasks.RL4`
- ‚úÖ Cross-file coherence: `grep taskId terminal-events.jsonl | match with Tasks.RL4`
- ‚úÖ Bias calculation: `node -e "console.log(proposals.reduce((sum, t) => sum + t.bias, 0))"`

### Next Steps

**Court terme:**
1. ‚úÖ Cr√©er script test-rl4-automation.sh
2. ‚úÖ Run tests ‚Üí 97.8% success rate
3. ‚úÖ Cleanup test files
4. ‚è≥ Ajouter ADR-009 dans ADRs.RL4
5. ‚è≥ Commit avec message structur√©

**Moyen terme (Phase E4):**
- [ ] Int√©grer dans GitHub Actions (CI/CD)
- [ ] Ajouter tests UI avec Playwright
- [ ] Coverage TypeScript avec Jest (objectif: 80%)
- [ ] Pre-commit hook auto-run tests

**Long terme:**
- [ ] E2E tests avec VS Code Extension Test API
- [ ] Performance benchmarks (snapshot generation <5s)
- [ ] Regression tests auto-generated depuis bugs

---

_This file is managed by RL4. Add ADRs here as they are proposed by the agent._
