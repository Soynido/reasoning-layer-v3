import * as fs from 'fs';
import * as path from 'path';
import { v4 as uuidv4 } from 'uuid';
import { ADR, ADRSearchFilter } from './types';
import { validateADR } from './schema';

/**
 * RBOMEngine - Gestion des ADRs (Architectural Decision Records)
 * 
 * Opérations CRUD de base pour les ADRs
 */
export class RBOMEngine {
    private adrsDir: string;
    private adrsIndexPath: string;
    private adrs: Map<string, ADR> = new Map();

    constructor(workspaceRoot: string) {
        this.adrsDir = path.join(workspaceRoot, '.reasoning', 'adrs');
        this.adrsIndexPath = path.join(this.adrsDir, 'index.json');
        
        // Créer le dossier si nécessaire
        if (!fs.existsSync(this.adrsDir)) {
            fs.mkdirSync(this.adrsDir, { recursive: true });
        }
        
        // Charger les ADRs existants
        this.loadIndex();
    }

    /**
     * Créer un nouvel ADR
     */
    public createADR(data: Partial<ADR>): ADR | null {
        try {
            const now = new Date().toISOString();
            const adr: ADR = {
                id: uuidv4(),
                title: data.title || 'Untitled ADR',
                status: data.status || 'proposed',
                createdAt: now,
                modifiedAt: now,
                author: data.author || 'unknown',
                context: data.context || '',
                decision: data.decision || '',
                consequences: data.consequences || '',
                tags: data.tags || [],
                components: data.components || [],
                relatedADRs: data.relatedADRs || [],
                evidenceIds: data.evidenceIds || [],
                lastSyncedAt: data.lastSyncedAt,
                autoGenerated: data.autoGenerated || false
            };

            // Valider avec Zod
            const validated = validateADR(adr);
            if (!validated) {
                console.error('Failed to validate ADR');
                return null;
            }

            // Sauvegarder
            this.saveADR(adr);
            this.adrs.set(adr.id, adr);
            this.saveIndex();

            return adr;
        } catch (error) {
            console.error('Failed to create ADR:', error);
            return null;
        }
    }

    /**
     * Lire un ADR par ID
     */
    public getADR(id: string): ADR | null {
        if (this.adrs.has(id)) {
            return this.adrs.get(id) || null;
        }

        // Charger depuis le fichier si non dans le cache
        const filePath = path.join(this.adrsDir, `${id}.json`);
        if (fs.existsSync(filePath)) {
            try {
                const content = fs.readFileSync(filePath, 'utf-8');
                const adr = JSON.parse(content) as ADR;
                this.adrs.set(adr.id, adr);
                return adr;
            } catch (error) {
                console.error(`Failed to load ADR ${id}:`, error);
            }
        }

        return null;
    }

    /**
     * Mettre à jour un ADR
     */
    public updateADR(id: string, updates: Partial<ADR>): ADR | null {
        const adr = this.getADR(id);
        if (!adr) {
            console.error(`ADR not found: ${id}`);
            return null;
        }

        const updated: ADR = {
            ...adr,
            ...updates,
            id: adr.id, // ID ne peut pas être modifié
            createdAt: adr.createdAt, // createdAt ne peut pas être modifié
            modifiedAt: new Date().toISOString()
        };

        // Valider
        const validated = validateADR(updated);
        if (!validated) {
            console.error('Failed to validate updated ADR');
            return null;
        }

        // Sauvegarder
        this.saveADR(updated);
        this.adrs.set(id, updated);
        this.saveIndex();

        return updated;
    }

    /**
     * Supprimer un ADR
     */
    public deleteADR(id: string): boolean {
        const filePath = path.join(this.adrsDir, `${id}.json`);
        
        if (fs.existsSync(filePath)) {
            try {
                fs.unlinkSync(filePath);
                this.adrs.delete(id);
                this.saveIndex();
                return true;
            } catch (error) {
                console.error(`Failed to delete ADR ${id}:`, error);
                return false;
            }
        }

        return false;
    }

    /**
     * Lister tous les ADRs
     */
    public listADRs(filter?: ADRSearchFilter): ADR[] {
        const adrs = Array.from(this.adrs.values());

        if (!filter) {
            return adrs;
        }

        // Appliquer les filtres
        return adrs.filter(adr => {
            if (filter.status && adr.status !== filter.status) {
                return false;
            }

            if (filter.tags && filter.tags.length > 0) {
                const hasTag = filter.tags.some(tag => adr.tags.includes(tag));
                if (!hasTag) {
                    return false;
                }
            }

            if (filter.components && filter.components.length > 0) {
                const hasComponent = filter.components.some(comp => adr.components.includes(comp));
                if (!hasComponent) {
                    return false;
                }
            }

            if (filter.author && adr.author !== filter.author) {
                return false;
            }

            return true;
        });
    }

    /**
     * Lier un Evidence à un ADR
     */
    public linkEvidence(adrId: string, evidenceId: string): boolean {
        const adr = this.getADR(adrId);
        if (!adr) {
            return false;
        }

        if (!adr.evidenceIds.includes(evidenceId)) {
            adr.evidenceIds.push(evidenceId);
            this.saveADR(adr);
            this.saveIndex();
        }

        return true;
    }

    /**
     * Délier un Evidence d'un ADR
     */
    public unlinkEvidence(adrId: string, evidenceId: string): boolean {
        const adr = this.getADR(adrId);
        if (!adr) {
            return false;
        }

        const index = adr.evidenceIds.indexOf(evidenceId);
        if (index > -1) {
            adr.evidenceIds.splice(index, 1);
            this.saveADR(adr);
            this.saveIndex();
        }

        return true;
    }

    // Private methods

    private saveADR(adr: ADR): void {
        try {
            const filePath = path.join(this.adrsDir, `${adr.id}.json`);
            fs.writeFileSync(filePath, JSON.stringify(adr, null, 2), 'utf-8');
        } catch (error) {
            console.error('Failed to save ADR:', error);
        }
    }

    private loadIndex(): void {
        if (fs.existsSync(this.adrsIndexPath)) {
            try {
                const content = fs.readFileSync(this.adrsIndexPath, 'utf-8');
                const data = JSON.parse(content);
                
                if (data.adrIds && Array.isArray(data.adrIds)) {
                    // Charger les IDs mais pas les données complètes
                    data.adrIds.forEach((id: string) => {
                        const filePath = path.join(this.adrsDir, `${id}.json`);
                        if (fs.existsSync(filePath)) {
                            try {
                                const adrContent = fs.readFileSync(filePath, 'utf-8');
                                const adr = JSON.parse(adrContent);
                                this.adrs.set(id, adr);
                            } catch (error) {
                                console.error(`Failed to load ADR ${id}:`, error);
                            }
                        }
                    });
                }
            } catch (error) {
                console.error('Failed to load ADR index:', error);
            }
        }
    }

    private saveIndex(): void {
        try {
            const adrIds = Array.from(this.adrs.keys());
            const data = { adrIds, lastUpdated: new Date().toISOString() };
            fs.writeFileSync(this.adrsIndexPath, JSON.stringify(data, null, 2), 'utf-8');
        } catch (error) {
            console.error('Failed to save ADR index:', error);
        }
    }
}

