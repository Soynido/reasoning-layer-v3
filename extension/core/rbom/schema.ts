import { z } from 'zod';
import { ADR } from './types';

/**
 * Zod schema pour validation des ADRs
 * 
 * Assure la structure cohérente et la validité des données
 */
export const ADRSchema = z.object({
    id: z.string().uuid('Invalid ADR ID format'),
    title: z.string().min(1, 'Title is required'),
    status: z.enum(['proposed', 'accepted', 'deprecated', 'superseded']),
    createdAt: z.string(), // ISO 8601 format
    modifiedAt: z.string(), // ISO 8601 format
    author: z.string().min(1, 'Author is required'),
    
    // Contenu
    context: z.string(),
    decision: z.string(),
    consequences: z.string(),
    
    // Métadonnées
    tags: z.array(z.string()),
    components: z.array(z.string()),
    relatedADRs: z.array(z.string()),
    
    // Liens avec Evidence (IDs de traces, pas nécessairement des UUID)
    evidenceIds: z.array(z.string().min(1)),
    
    // Génération automatique
    lastSyncedAt: z.string().optional(), // ISO 8601 format
    autoGenerated: z.boolean(),
    
    // Enhanced fields (Phase 2 - optional for backward compatibility)
    tradeoffs: z.object({
        pros: z.array(z.string()),
        cons: z.array(z.string())
    }).optional(),
    rejectedOptions: z.array(z.object({
        option: z.string(),
        reason: z.string()
    })).optional(),
    assumptions: z.array(z.string()).optional(),
    constraints: z.object({
        technical: z.array(z.string()).optional(),
        business: z.array(z.string()).optional(),
        timeline: z.string().optional()
    }).optional(),
    risks: z.array(z.object({
        risk: z.string(),
        probability: z.enum(['low', 'medium', 'high']),
        impact: z.enum(['low', 'medium', 'high']),
        mitigation: z.string().optional()
    })).optional(),
    mitigations: z.array(z.string()).optional(),
    supersededBy: z.string().optional(),
    supersedes: z.array(z.string()).optional()
});

/**
 * Valide un objet ADR
 */
export function validateADR(data: unknown): ADR | null {
    try {
        const validated = ADRSchema.parse(data);
        return validated as ADR;
    } catch (error) {
        if (error instanceof z.ZodError) {
            const issues = error.issues.map(issue => `${issue.path.join('.')}: ${issue.message}`).join(', ');
            console.error('ADR validation failed:', issues);
            console.error('Failed data:', JSON.stringify(data, null, 2));
        }
        return null;
    }
}

/**
 * Valide un nouveau ADR (pour création)
 */
export const CreateADRSchema = ADRSchema.omit({ 
    id: true, 
    createdAt: true, 
    modifiedAt: true,
    lastSyncedAt: true,
    evidenceIds: true,
    autoGenerated: true
}).extend({
    title: z.string().min(1),
    author: z.string().min(1),
    status: z.enum(['proposed', 'accepted', 'deprecated', 'superseded']).default('proposed')
});

/**
 * Valide un ADR pour mise à jour
 */
export const UpdateADRSchema = ADRSchema.partial().required({ id: true });

