import * as fs from 'fs';
import * as path from 'path';
import { PersistenceManager } from '../PersistenceManager';
import { RBOMEngine } from './RBOMEngine';
import { CaptureEvent, GitCommitData } from '../types';
import { ADR } from './types';

interface EventSummary {
    totalEvents: number;
    byType: Record<string, number>;
    byFile: Record<string, number>;
    byCategory: Record<string, number>;
    timeRange: { start: string; end: string };
    keyFiles: string[];
    majorChanges: {
        description: string;
        files: string[];
        count: number;
        timestamp: string;
    }[];
    dependencyHistory: string[];
    gitEvolution: {
        branches: string[];
        commitsByAuthor: Record<string, number>;
    };
}

interface ADRFromSummary {
    title: string;
    context: string;
    decision: string;
    consequences: string;
    components: string[];
    evidenceIds: string[];
    tags: string[];
    confidence: number; // 0-1
}

// ‚úÖ DecisionPattern pour la d√©tection heuristique
interface DecisionPattern {
    type: 'Dependency' | 'Config' | 'Refactor' | 'Test' | 'Feature' | 'Architecture';
    confidence: number; // 0-1
    changes: number;
    commit?: {
        hash: string;
        message: string;
        author: string;
        date: string;
        filesChanged: string[];
        insertions: number;
        deletions: number;
    };
    dependencies?: string[];
    configFiles?: string[];
    score: number; // Score calcul√©
}

/**
 * DecisionSynthesizer - Analyse historique compl√®te et g√©n√®re des ADRs
 * 
 * Utilise une approche "long-form reasoning" sur tout l'historique
 */
export class DecisionSynthesizer {
    private lastSynthesis: number = 0;

    constructor(
        private workspaceRoot: string,
        private persistence: PersistenceManager,
        private rbomEngine: RBOMEngine
    ) {
        this.persistence.logWithEmoji('üß†', 'DecisionSynthesizer initialized with historical analysis');
    }

    /**
     * Auto-synth√®se rapide sur les 250 derniers √©v√©nements
     * D√©tection heuristique avec score ‚â• 0.6
     */
    public async runAutoSynthesis(): Promise<void> {
        try {
            const events = this.loadRecentEvents(250);
            if (events.length === 0) {
                this.persistence.logWithEmoji('‚ö†Ô∏è', 'No recent events found for auto-synthesis');
                return;
            }

            this.persistence.logWithEmoji('üîç', `Auto-synthesis: analyzing ${events.length} recent events...`);
            
            const patterns = this.detectDecisionPatterns(events);
            if (patterns.length === 0) {
                this.persistence.logWithEmoji('‚úì', 'No decision patterns detected (confidence < 0.6)');
                return;
            }

            this.persistence.logWithEmoji('üéØ', `Found ${patterns.length} decision pattern(s) with score ‚â• 0.6`);

            for (const pattern of patterns) {
                const adr = this.generateADR(pattern, events);
                const savedAdr = this.rbomEngine.createADR({
                    title: adr.title,
                    status: 'accepted',
                    author: adr.author,
                    context: adr.context,
                    decision: adr.decision,
                    consequences: adr.consequences,
                    tags: adr.tags,
                    components: adr.components,
                    evidenceIds: adr.evidenceIds,
                    autoGenerated: true
                });

                if (savedAdr) {
                    this.persistence.logWithEmoji('‚úÖ', `ADR auto-generated: ${adr.title} (confidence: ${(pattern.score * 100).toFixed(0)}%)`);
                }
            }
        } catch (error) {
            this.persistence.logWithEmoji('‚ùå', `Auto-synthesis failed: ${error}`);
        }
    }

    private loadRecentEvents(limit: number): CaptureEvent[] {
        const tracesDir = path.join(this.workspaceRoot, '.reasoning', 'traces');
        if (!fs.existsSync(tracesDir)) return [];

        const allEvents: CaptureEvent[] = [];
        const files = fs.readdirSync(tracesDir)
            .filter(f => f.endsWith('.json'))
            .sort()
            .reverse(); // Plus r√©cents en premier

        for (const file of files) {
            try {
                const filePath = path.join(tracesDir, file);
                const events: CaptureEvent[] = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
                allEvents.push(...events);
                if (allEvents.length >= limit) break;
            } catch {
                // Ignore corrupted files
            }
        }

        return allEvents.slice(0, limit);
    }

    /**
     * D√©tection heuristique des patterns de d√©cision
     * Score ‚â• 0.6 = ADR probable
     */
    private detectDecisionPatterns(events: CaptureEvent[]): DecisionPattern[] {
        const patterns: DecisionPattern[] = [];
        
        // Grouper par commit
        const commits = this.groupByCommit(events);
        
        for (const commit of commits) {
            let score = 0;
            const filesChanged = commit.filesChanged.length;
            const hasDependencyChange = commit.filesChanged.some(f => 
                f.includes('package') || f.includes('requirements') || f.includes('Cargo')
            );
            const hasConfigChange = commit.filesChanged.some(f =>
                f.includes('.env') || f.includes('.yml') || f.includes('.yaml') || f.includes('.json')
            );
            const hasTestChange = commit.filesChanged.some(f => 
                f.includes('test') || f.includes('spec') || f.includes('__tests__')
            );
            
            // Scoring heuristique
            if (filesChanged > 10) score += 0.4; // Refactor/Architecture
            if (hasDependencyChange) score += 0.6; // Dependency decision
            if (hasConfigChange) score += 0.5; // Environment decision
            if (hasTestChange) score += 0.3; // Quality/coverage
            
            // Analyse du message de commit
            const message = commit.message.toLowerCase();
            if (message.match(/migrate|refactor|replace|switch/)) score += 0.4;
            if (message.match(/fix|patch|deprecated/)) score += 0.2;
            
            // Score final
            score = Math.min(1, score);
            
            // Si score ‚â• 0.6, c'est une d√©cision probable
            if (score >= 0.6) {
                let type: DecisionPattern['type'] = 'Feature';
                if (hasDependencyChange) type = 'Dependency';
                else if (hasConfigChange) type = 'Config';
                else if (filesChanged > 10) type = 'Architecture';
                else if (hasTestChange) type = 'Test';
                
                console.log(
                    `üîç Detected ${type} pattern in commit ${commit.hash} | confidence: ${score.toFixed(2)} | files: ${filesChanged}`
                );
                
                patterns.push({
                    type,
                    confidence: score,
                    changes: filesChanged,
                    commit,
                    score
                });
            }
        }
        
        return patterns;
    }

    /**
     * Grouper les √©v√©nements par commit
     */
    private groupByCommit(events: CaptureEvent[]): Array<{
        hash: string;
        message: string;
        author: string;
        date: string;
        filesChanged: string[];
        insertions: number;
        deletions: number;
    }> {
        const commits = new Map<string, {
            hash: string;
            message: string;
            author: string;
            date: string;
            filesChanged: string[];
            insertions: number;
            deletions: number;
        }>();
        
        for (const event of events) {
            // Accepter √† la fois git_commit ET file_change avec metadata.commit
            if ((event.type === 'git_commit' || event.type === 'file_change') && event.metadata?.commit) {
                const commitData = event.metadata.commit as any;
                // Extraire le hash depuis source ou commit
                let hash = '';
                if (event.source.includes(':') && event.source.includes('git:')) {
                    hash = event.source.split(':')[1];
                } else if (commitData.hash) {
                    hash = commitData.hash;
                }
                
                if (!hash) continue;
                
                if (!commits.has(hash)) {
                    commits.set(hash, {
                        hash,
                        message: commitData.message || '',
                        author: commitData.author || commitData.author_name || 'unknown',
                        date: commitData.timestamp || commitData.date || event.timestamp,
                        filesChanged: commitData.files || commitData.files_changed || [],
                        insertions: commitData.insertions || 0,
                        deletions: commitData.deletions || 0
                    });
                } else {
                    // Fusionner les fichiers
                    const existing = commits.get(hash)!;
                    const newFiles = commitData.files || commitData.files_changed || [];
                    existing.filesChanged = [...new Set([...existing.filesChanged, ...newFiles])];
                    existing.insertions += commitData.insertions || 0;
                    existing.deletions += commitData.deletions || 0;
                }
            }
        }
        
        return Array.from(commits.values());
    }

    /**
     * G√©n√©rer un ADR √† partir d'un pattern d√©tect√©
     */
    private generateADR(pattern: DecisionPattern, events: CaptureEvent[]): {
        title: string;
        context: string;
        decision: string;
        consequences: string;
        author: string;
        tags: string[];
        components: string[];
        evidenceIds: string[];
    } {
        const title = `Auto-ADR: ${pattern.type} decision (${pattern.commit?.hash.substring(0, 7) || 'unknown'})`;
        const context = this.describeProblem(pattern);
        const decision = this.inferDecision(pattern);
        const consequences = this.inferConsequences(pattern);
        
        // Trouver les preuves (events li√©s au commit)
        const evidenceIds = events
            .filter(e => e.source.includes(pattern.commit?.hash || ''))
            .map(e => e.id)
            .slice(0, 10);
        
        const components = pattern.commit?.filesChanged.slice(0, 5) || [];
        
        return {
            title,
            context,
            decision,
            consequences,
            author: `system:auto-${pattern.type}`,
            tags: [pattern.type.toLowerCase(), 'auto-generated', 'heuristic'],
            components,
            evidenceIds
        };
    }

    private describeProblem(pattern: DecisionPattern): string {
        const changeCount = pattern.changes;
        const type = pattern.type;
        
        if (type === 'Dependency') {
            return `Detected dependency update with ${changeCount} file changes. The project structure shows modifications to package management and dependency files.`;
        }
        if (type === 'Config') {
            return `Detected configuration changes across ${changeCount} files. Environment settings, build configuration, or deployment parameters were modified.`;
        }
        if (type === 'Architecture' || type === 'Refactor') {
            return `Detected architectural refactoring with ${changeCount} files modified. This suggests a significant structural change to the codebase.`;
        }
        if (type === 'Test') {
            return `Detected test coverage changes with ${changeCount} files modified. Quality assurance and testing infrastructure were updated.`;
        }
        return `Detected significant changes: ${changeCount} files modified in a ${type} context.`;
    }

    private inferDecision(pattern: DecisionPattern): string {
        const type = pattern.type;
        
        if (type === 'Dependency') {
            return `Updated package dependencies to improve security, reduce version conflicts, and modernize the dependency stack.`;
        }
        if (type === 'Config') {
            return `Modified configuration to adapt to new environment requirements, improve deployment process, or optimize runtime settings.`;
        }
        if (type === 'Architecture') {
            return `Restructured core architecture to improve maintainability, reduce technical debt, and enable future scalability.`;
        }
        if (type === 'Test') {
            return `Enhanced test coverage and quality assurance to improve code reliability and catch regressions earlier.`;
        }
        return `Made ${type} decision to improve project quality and maintainability.`;
    }

    private inferConsequences(pattern: DecisionPattern): string {
        const type = pattern.type;
        
        if (type === 'Dependency') {
            return `Reduced security vulnerabilities; improved dependency tree; potential API incompatibilities require testing.`;
        }
        if (type === 'Config') {
            return `Improved environment configuration; potential deployment adjustments needed; runtime behavior may change.`;
        }
        if (type === 'Architecture' || type === 'Refactor') {
            return `Improved code maintainability; reduced technical debt; potential breaking changes require team coordination.`;
        }
        if (type === 'Test') {
            return `Improved code quality; better regression detection; longer CI/CD pipeline.`;
        }
        return `Positive impact on project quality; requires testing and validation.`;
    }

    public async synthesizeHistoricalDecisions(): Promise<void> {
        const now = Date.now();
        if (now - this.lastSynthesis < 300000) { // Synth√®se toutes les 5 minutes
            return;
        }
        this.lastSynthesis = now;

        try {
            // ‚úÖ √âtape 1 : Lire toutes les traces
            const allEvents = this.loadAllEvents();
            if (allEvents.length === 0) {
                this.persistence.logWithEmoji('‚ö†Ô∏è', 'No historical events found');
                return;
            }

            this.persistence.logWithEmoji('üìö', `Analyzing ${allEvents.length} historical events...`);

            // ‚úÖ √âtape 2 : Pr√©-filtrage intelligent
            const summary = this.createIntelligentSummary(allEvents);
            
            this.persistence.logWithEmoji('üîç', `Summary: ${summary.totalEvents} events, ${summary.majorChanges.length} major changes`);

            // ‚úÖ √âtape 3 : Raisonnement architectural
            const adrCandidates = this.reasonArchitecturalDecisions(summary, allEvents);

            // ‚úÖ √âtape 4 : G√©n√©rer les ADRs
            if (adrCandidates.length > 0) {
                this.persistence.logWithEmoji('üéØ', `Generated ${adrCandidates.length} architectural decisions`);
                for (const candidate of adrCandidates) {
                    await this.createADRFromSynthesis(candidate);
                }
            }

        } catch (error) {
            this.persistence.logWithEmoji('‚ùå', `Synthesis failed: ${error}`);
        }
    }

    private loadAllEvents(): CaptureEvent[] {
        const tracesDir = path.join(this.workspaceRoot, '.reasoning', 'traces');
        if (!fs.existsSync(tracesDir)) return [];

        const allEvents: CaptureEvent[] = [];
        const files = fs.readdirSync(tracesDir).filter(f => f.endsWith('.json')).sort();

        for (const file of files) {
            try {
                const filePath = path.join(tracesDir, file);
                const events: CaptureEvent[] = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
                allEvents.push(...events);
            } catch (error) {
                // Ignore corrupted files
            }
        }

        return allEvents;
    }

    private createIntelligentSummary(events: CaptureEvent[]): EventSummary {
        const summary: EventSummary = {
            totalEvents: events.length,
            byType: {},
            byFile: {},
            byCategory: {},
            timeRange: { start: events[0]?.timestamp || '', end: events[events.length - 1]?.timestamp || '' },
            keyFiles: [],
            majorChanges: [],
            dependencyHistory: [],
            gitEvolution: {
                branches: [],
                commitsByAuthor: {}
            }
        };

        // Grouper par type
        for (const event of events) {
            summary.byType[event.type] = (summary.byType[event.type] || 0) + 1;
            
            const fileName = path.basename(event.source);
            summary.byFile[fileName] = (summary.byFile[fileName] || 0) + 1;
            
            const category = event.metadata?.category || event.metadata?.level || 'unknown';
            summary.byCategory[category] = (summary.byCategory[category] || 0) + 1;

            // D√©tecter les d√©pendances
            if (event.type === 'dependencies' && event.metadata?.dependencies) {
                const deps = event.metadata.dependencies as any[];
                deps.forEach(dep => {
                    if (dep.name && !summary.dependencyHistory.includes(dep.name)) {
                        summary.dependencyHistory.push(dep.name);
                    }
                });
            }

            // D√©tecter l'√©volution Git
            if (event.type === 'git_commit' && event.metadata?.commit) {
                const author = event.metadata.commit.author || 'unknown';
                summary.gitEvolution.commitsByAuthor[author] = (summary.gitEvolution.commitsByAuthor[author] || 0) + 1;
            }
        }

        // Identifier les fichiers cl√©s (les plus modifi√©s)
        const sortedFiles = Object.entries(summary.byFile)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 20);
        summary.keyFiles = sortedFiles.map(([file]) => file);

        // D√©tecter les changements majeurs
        const fileGroups = new Map<string, CaptureEvent[]>();
        for (const event of events) {
            const dir = path.dirname(event.source);
            if (!fileGroups.has(dir)) fileGroups.set(dir, []);
            fileGroups.get(dir)!.push(event);
        }

        for (const [dir, dirEvents] of fileGroups.entries()) {
            if (dirEvents.length >= 5) {
                const recentEvent = dirEvents[dirEvents.length - 1];
                summary.majorChanges.push({
                    description: `Intensive development in ${path.basename(dir)}`,
                    files: dirEvents.map(e => path.basename(e.source)),
                    count: dirEvents.length,
                    timestamp: recentEvent.timestamp
                });
            }
        }

        return summary;
    }

    private reasonArchitecturalDecisions(summary: EventSummary, events: CaptureEvent[]): ADRFromSummary[] {
        const decisions: ADRFromSummary[] = [];

        // ‚úÖ Pattern 1: Structure de persistance √©tablie
        // Intent: D√©tecter la d√©cision humaine de stabiliser un contrat de persistance
        if (summary.byFile['PersistenceManager.ts'] > 3 || summary.byFile['ManifestGenerator.ts'] > 2) {
            const persistenceEvents = events.filter(e => 
                e.source.includes('PersistenceManager') || 
                e.source.includes('ManifestGenerator') ||
                e.source.includes('SchemaManager')
            );

            decisions.push({
                title: 'Stabilisation du contrat de persistance via manifest versionn√©',
                context: `Le d√©veloppeur a it√©r√© ${summary.byFile['PersistenceManager.ts'] || 0} fois sur PersistenceManager et ${summary.byFile['ManifestGenerator.ts'] || 0} fois sur ManifestGenerator. L'intention implicite √©tait de garantir la coh√©rence des donn√©es captur√©es.`,
                decision: 'Le choix fait: impl√©menter un moteur de persistance local-first avec manifest versionn√© et sch√©ma Zod pour validation. Cette d√©cision visait √† √©viter la corruption de donn√©es et faciliter le debugging.',
                consequences: 'Impact observable: architecture locale sans d√©pendance serveur, validation syst√©matique des √©v√©nements, manifest toujours en coh√©rence avec les traces.',
                components: ['PersistenceManager.ts', 'ManifestGenerator.ts', 'SchemaManager.ts'],
                evidenceIds: persistenceEvents.map(e => e.id).slice(0, 5),
                tags: ['decision', 'persistence', 'data-integrity'],
                confidence: 0.95
            });
        }

        // ‚úÖ Pattern 2: Capture d'√©v√©nements multi-capteurs
        const captureEngines = ['SBOMCaptureEngine', 'ConfigCaptureEngine', 'TestCaptureEngine', 'GitMetadataEngine'];
        const enginesDetected = captureEngines.filter(engine => {
            return Object.keys(summary.byFile).some(file => file.includes(engine.replace('Engine', '')));
        });

        if (enginesDetected.length >= 2) {
            decisions.push({
                title: 'Adoption d\'une architecture modulaire par capteur sp√©cialis√©',
                context: `Le d√©veloppement montre la cr√©ation de ${enginesDetected.length} engines s√©par√©s (${enginesDetected.join(', ')}). L'intention √©tait de d√©coupler les responsabilit√©s de capture par domaine technique.`,
                decision: 'Le choix fait: un engine par type de m√©tadonn√©e plut√¥t qu\'un capteur monolithique. Cette d√©cision visait √† am√©liorer la maintenabilit√© et tester chaque capteur ind√©pendamment.',
                consequences: 'Impact observable: le code est plus modulaire, chaque engine peut √©voluer sans affecter les autres. Cela facilite l\'ajout de nouveaux capteurs.',
                components: enginesDetected,
                evidenceIds: events.slice(0, 10).map(e => e.id),
                tags: ['decision', 'architecture', 'modularity'],
                confidence: 0.90
            });
        }

        // ‚úÖ Pattern 3: D√©pendances strat√©giques
        const strategicDeps = summary.dependencyHistory.filter(dep => 
            dep.includes('git') || dep.includes('zod') || dep.includes('uuid')
        );
        if (strategicDeps.length > 0) {
            decisions.push({
                title: `Adoption de librairies externes pour ${strategicDeps.join(', ')}`,
                context: `Le projet a ajout√© les d√©pendances ${strategicDeps.join(' et ')} dans package-lock.json. L'intention √©tait d'utiliser des solutions matures plut√¥t que de r√©inventer.`,
                decision: `Le choix fait: utiliser ${strategicDeps.map(d => `${d} (${this.getDepPurpose(d)})`).join(' et ')}. Cette d√©cision visait √† gagner du temps et √©viter les bugs.`,
                consequences: 'Impact observable: code plus stable, moins de maintenance, mais d√©pendance de communaut√© externe.',
                components: ['package-lock.json'],
                evidenceIds: events.filter(e => e.type === 'dependencies').map(e => e.id).slice(0, 5),
                tags: ['decision', 'dependencies', 'trade-off'],
                confidence: 0.85
            });
        }

        // ‚úÖ Pattern 4: √âvolution Git structur√©e
        if (summary.gitEvolution.commitsByAuthor) {
            const totalCommits = Object.values(summary.gitEvolution.commitsByAuthor).reduce((a, b) => a + b, 0);
            if (totalCommits > 10) {
                const authors = Object.keys(summary.gitEvolution.commitsByAuthor);
                decisions.push({
                    title: 'Usage de Git pour tra√ßabilit√© des d√©cisions via historique',
                    context: `${totalCommits} commits d√©tect√©s, ${authors.length} contributeur(s). Le d√©veloppement montre l'utilisation de Git comme outil de tra√ßabilit√©.`,
                    decision: 'Le choix fait: maintenir un historique Git complet avec commits structur√©s. Cette d√©cision visait √† documenter naturellement les changements.',
                    consequences: 'Impact observable: L\'historique Git devient source de v√©rit√© pour comprendre l\'√©volution du projet.',
                    components: ['git'],
                    evidenceIds: events.filter(e => e.type === 'git_commit').map(e => e.id).slice(0, 5),
                    tags: ['decision', 'git', 'traceability'],
                    confidence: 0.80
                });
            }
        }

        // ‚úÖ Pattern 5: Refactor majeur d√©tect√©
        if (summary.majorChanges.length > 0) {
            const biggestChange = summary.majorChanges.sort((a, b) => b.count - a.count)[0];
            if (biggestChange.count >= 10) {
                const changeEvents = events.filter(e => 
                    biggestChange.files.some(file => e.source.includes(file))
                );

                decisions.push({
                    title: `Refactor majeur de ${path.basename(biggestChange.files[0]?.split('/')[0] || 'unknown')}`,
                    context: `${biggestChange.count} modifications d√©tect√©es sur ${biggestChange.files.length} fichiers dans ${biggestChange.description}. Le d√©veloppeur a choisi de refactoriser plut√¥t que d'ajouter des patches.`,
                    decision: 'Le choix fait: refactoriser plut√¥t que d\'ajouter des workarounds. Cette d√©cision visait √† am√©liorer la maintenabilit√© √† long terme.',
                    consequences: 'Impact observable: code plus propre, architecture plus claire, mais risque de breaking changes √† court terme.',
                    components: biggestChange.files,
                    evidenceIds: changeEvents.map(e => e.id).slice(0, 10),
                    tags: ['decision', 'refactor', 'trade-off'],
                    confidence: 0.75
                });
            }
        }

        return decisions;
    }

    private getDepPurpose(name: string): string {
        if (name.includes('git')) return 'int√©gration Git native';
        if (name.includes('zod')) return 'validation de sch√©mas';
        if (name.includes('uuid')) return 'g√©n√©ration d\'identifiants uniques';
        if (name.includes('webpack')) return 'bundling et compilation';
        return 'fonctionnalit√© sp√©cifique';
    }

    private async createADRFromSynthesis(candidate: ADRFromSummary): Promise<void> {
        try {
            // V√©rifier les doublons
            const existingADRs = this.rbomEngine.listADRs();
            const similarADR = existingADRs.find(adr => 
                adr.title.toLowerCase() === candidate.title.toLowerCase()
            );

            if (similarADR) {
                this.persistence.logWithEmoji('‚è≠Ô∏è', `ADR d√©j√† existant: ${candidate.title}`);
                return;
            }

            const adr = this.rbomEngine.createADR({
                title: candidate.title,
                status: 'accepted', // Auto-g√©n√©r√© = d√©j√† accept√© (fait historique)
                author: 'system:historical-analysis',
                context: candidate.context,
                decision: candidate.decision,
                consequences: candidate.consequences,
                tags: [...candidate.tags, 'auto-generated', 'historical'],
                components: candidate.components,
                relatedADRs: [],
                evidenceIds: [],
                autoGenerated: true
            });

            if (adr) {
                // Link evidence
                for (const evidenceId of candidate.evidenceIds) {
                    this.rbomEngine.linkEvidence(adr.id, evidenceId);
                }

                this.persistence.logWithEmoji('üß†', `Historical ADR synthesized: ${adr.title} (confidence: ${(candidate.confidence * 100).toFixed(0)}%)`);
            }

        } catch (error) {
            this.persistence.logWithEmoji('‚ùå', `Failed to create synthesized ADR: ${error}`);
        }
    }
}

